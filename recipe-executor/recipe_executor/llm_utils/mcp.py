# This file was generated by Codebase-Generator, do not edit directly
"""
MCP utilities for creating PydanticAI MCP server instances from configuration.
"""

import os
import logging
from typing import Any, Dict, Optional

from dotenv import load_dotenv
from pydantic_ai.mcp import MCPServer, MCPServerHTTP, MCPServerStdio


def get_mcp_server(logger: logging.Logger, config: Dict[str, Any]) -> MCPServer:
    """
    Create an MCPServer instance based on the provided configuration.

    Args:
        logger: Logger for logging messages.
        config: Configuration dict for the MCP server.

    Returns:
        A configured PydanticAI MCPServer instance.

    Raises:
        ValueError: If the configuration is invalid.
        RuntimeError: If server instantiation fails.
    """
    # Sanitize config for logging (mask sensitive values)
    sanitized = config.copy()
    if "headers" in sanitized and isinstance(sanitized["headers"], dict):
        sanitized["headers"] = {k: "***" for k in sanitized["headers"]}
    if "env" in sanitized and isinstance(sanitized["env"], dict):
        sanitized["env"] = {k: "***" for k in sanitized["env"]}
    logger.debug("get_mcp_server config: %s", sanitized)

    try:
        # HTTP transport
        if "url" in config:
            url = config.get("url")
            if not isinstance(url, str) or not url:
                raise ValueError("Invalid 'url' for HTTP MCP server")

            headers = config.get("headers")
            if headers is not None and not isinstance(headers, dict):
                raise ValueError("'headers' must be a dict for HTTP MCP server")

            tool_prefix = config.get("tool_prefix")
            logger.info("Creating HTTP MCP server: url=%s prefix=%s", url, tool_prefix)
            return MCPServerHTTP(url=url, headers=headers, tool_prefix=tool_prefix)

        # stdio transport
        if "command" in config:
            command = config.get("command")
            if not isinstance(command, str) or not command:
                raise ValueError("Invalid 'command' for stdio MCP server")

            args = config.get("args")
            if args is None or not isinstance(args, list) or not all(isinstance(a, str) for a in args):
                raise ValueError("'args' must be a list of strings for stdio MCP server")

            env_cfg = config.get("env")
            env: Optional[Dict[str, str]] = None
            if env_cfg is not None:
                if not isinstance(env_cfg, dict):
                    raise ValueError("'env' must be a dict of str to str for stdio MCP server")
                # load .env if any blank values to fill
                if any(v == "" for v in env_cfg.values()):
                    load_dotenv()
                env = {}
                for k, v in env_cfg.items():
                    if v == "":
                        val = os.getenv(k)
                        if val is None:
                            raise ValueError(f"Environment variable '{k}' not set in system or .env file")
                        env[k] = val
                    else:
                        env[k] = v

            cwd = config.get("working_dir")
            if cwd is not None and not isinstance(cwd, str):
                raise ValueError("'working_dir' must be a string for stdio MCP server")

            tool_prefix = config.get("tool_prefix")
            logger.info(
                "Creating stdio MCP server: command=%s args=%s prefix=%s cwd=%s", command, args, tool_prefix, cwd
            )
            return MCPServerStdio(command, args=args, env=env, cwd=cwd, tool_prefix=tool_prefix)

        raise ValueError("Configuration must include either 'url' for HTTP or 'command' for stdio MCP server")

    except (ValueError,) as ve:
        logger.error("Invalid MCP server configuration: %s", ve)
        raise
    except Exception as e:
        logger.error("Failed to create MCP server: %s", e)
        raise RuntimeError(f"Failed to create MCP server: {e}") from e
