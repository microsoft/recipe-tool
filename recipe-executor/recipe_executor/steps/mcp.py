# This file was generated by Codebase-Generator, do not edit directly
from typing import Any, Dict, List
import logging

from dotenv import load_dotenv
from recipe_executor.steps.base import BaseStep, StepConfig
from recipe_executor.protocols import ContextProtocol
from recipe_executor.utils.templates import render_template

from mcp.client.sse import sse_client
from mcp.client.stdio import stdio_client
from mcp import ClientSession, StdioServerParameters

load_dotenv()


class MCPConfig(StepConfig):
    """
    Configuration for MCPStep.

    Fields:
        server: Configuration for the MCP server.
        tool_name: Name of the tool to invoke.
        arguments: Arguments to pass to the tool as a dictionary.
        result_key: Context key under which to store the tool result as a dictionary.
    """

    server: Dict[str, Any]
    tool_name: str
    arguments: Dict[str, Any]
    result_key: str = "tool_result"


class MCPStep(BaseStep[MCPConfig]):
    """
    Step to call a tool on a remote MCP server and store the result in context.
    """

    def __init__(self, logger: logging.Logger, config: Dict[str, Any]) -> None:
        # Validate and store configuration
        super().__init__(logger, MCPConfig.model_validate(config))

    async def execute(self, context: ContextProtocol) -> None:
        # Resolve templated configuration values
        cfg = self.config
        # Render tool name
        tool_name = render_template(cfg.tool_name, context)
        # Render arguments dict
        resolved_args: Dict[str, Any] = {}
        for key, value in cfg.arguments.items():
            if isinstance(value, str):
                resolved_args[key] = render_template(value, context)
            else:
                resolved_args[key] = value
        # Determine server type
        server_conf = cfg.server
        self.logger.debug(f"Connecting to MCP server, config: {server_conf}")

        # HTTP (SSE) transport
        if "url" in server_conf:
            url = render_template(server_conf["url"], context)
            headers_conf = server_conf.get("headers")
            headers: Dict[str, Any] = {}
            if isinstance(headers_conf, dict):
                for hkey, hval in headers_conf.items():
                    if isinstance(hval, str):
                        headers[hkey] = render_template(hval, context)
                    else:
                        headers[hkey] = hval
            try:
                async with sse_client(url, headers=headers or None) as (read_stream, write_stream):
                    session = ClientSession(read_stream, write_stream)
                    await session.initialize()
                    self.logger.debug(f"Invoking MCP tool {tool_name} with arguments {resolved_args}")
                    try:
                        result = await session.call_tool(name=tool_name, arguments=resolved_args)
                    except Exception as e:
                        raise ValueError(f"Failed to call tool {tool_name} on MCP server: {e}") from e
            except ValueError:
                raise
            except Exception as e:
                raise ValueError(f"Failed to connect to MCP server at {url}: {e}") from e

        # stdio transport
        elif "command" in server_conf:
            cmd = render_template(server_conf["command"], context)
            args_conf = server_conf.get("args", []) or []
            cmd_args: List[str] = []
            for item in args_conf:
                if isinstance(item, str):
                    cmd_args.append(render_template(item, context))
                else:
                    cmd_args.append(item)
            env_conf = server_conf.get("env")
            env = None
            if isinstance(env_conf, dict):
                env = {}
                for ekey, eval_ in env_conf.items():
                    if isinstance(eval_, str):
                        env[ekey] = render_template(eval_, context)
                    else:
                        env[ekey] = eval_
            cwd_conf = server_conf.get("working_dir")
            cwd = None
            if isinstance(cwd_conf, str):
                cwd = render_template(cwd_conf, context)
            params = StdioServerParameters(command=cmd, args=cmd_args, env=env, cwd=cwd)
            try:
                async with stdio_client(params) as (read_stream, write_stream):
                    session = ClientSession(read_stream, write_stream)
                    await session.initialize()
                    self.logger.debug(f"Invoking MCP tool {tool_name} with arguments {resolved_args}")
                    try:
                        result = await session.call_tool(name=tool_name, arguments=resolved_args)
                    except Exception as e:
                        raise ValueError(f"Failed to call tool {tool_name} on MCP server: {e}") from e
            except ValueError:
                raise
            except Exception as e:
                raise ValueError(f"Failed to connect to MCP stdio server: {e}") from e

        else:
            raise ValueError("MCP server configuration must include 'url' or 'command'.")

        # Convert result to dict and store in context
        # Assume CallToolResult is a Pydantic model
        try:
            result_dict = result.model_dump()  # type: ignore[attr-defined]
        except Exception:
            # Fallback to __dict__
            result_dict = getattr(result, "__dict__", {})  # type: ignore
        context[cfg.result_key] = result_dict
