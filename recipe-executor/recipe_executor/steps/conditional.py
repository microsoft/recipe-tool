# This file was generated by Codebase-Generator, do not edit directly
import os
import re
from typing import Any, Dict, List, Optional

from recipe_executor.steps.base import BaseStep, StepConfig
from recipe_executor.protocols import ContextProtocol
from recipe_executor.utils.templates import render_template
from recipe_executor.steps.registry import STEP_REGISTRY


def _file_exists(path: str) -> bool:
    """Return True if the given path exists."""
    try:
        return os.path.exists(path)
    except Exception:
        return False


def _all_files_exist(paths: List[str]) -> bool:
    """Return True if all paths in the list exist."""
    try:
        return all(os.path.exists(p) for p in paths)
    except Exception:
        return False


def _file_is_newer(src: str, dst: str) -> bool:
    """Return True if src is newer than dst. If dst does not exist, returns True. If src does not exist, returns False."""
    try:
        if not os.path.exists(src):
            return False
        if not os.path.exists(dst):
            return True
        return os.path.getmtime(src) > os.path.getmtime(dst)
    except Exception:
        return False


def _and_(*args: Any) -> bool:
    """Logical AND over all arguments."""
    return all(bool(a) for a in args)


def _or_(*args: Any) -> bool:
    """Logical OR over all arguments."""
    return any(bool(a) for a in args)


class ConditionalConfig(StepConfig):
    """
    Configuration for ConditionalStep.

    Fields:
        condition: Expression string or boolean to evaluate.
        if_true: Optional branch config when condition is True.
        if_false: Optional branch config when condition is False.
    """

    condition: Any
    if_true: Optional[Dict[str, Any]] = None
    if_false: Optional[Dict[str, Any]] = None


class ConditionalStep(BaseStep[ConditionalConfig]):
    """Step that evaluates a condition and executes branches accordingly."""

    def __init__(self, logger: Any, config: Dict[str, Any]) -> None:
        # Validate and parse config
        validated = ConditionalConfig.model_validate(config)
        super().__init__(logger, validated)

    async def execute(self, context: ContextProtocol) -> None:
        raw_condition = self.config.condition
        # Determine the boolean result
        rendered: Any = None
        result: bool

        if isinstance(raw_condition, bool):
            rendered = raw_condition
            result = raw_condition
        elif isinstance(raw_condition, str):
            # Render template
            try:
                rendered = render_template(raw_condition, context)
            except Exception as e:
                raise RuntimeError(f"Error rendering condition template '{raw_condition}': {e}")
            expr = rendered.strip()
            # Direct boolean strings
            if expr.lower() in ("true", "false"):
                result = expr.lower() == "true"
            else:
                # Prepare safe evaluation
                # Replace functional 'and(' and 'or(' with internal names
                expr_safe = re.sub(r"\band\(", "_and_(", expr)
                expr_safe = re.sub(r"\bor\(", "_or_(", expr_safe)

                safe_globals = {
                    "__builtins__": {},
                    "file_exists": _file_exists,
                    "all_files_exist": _all_files_exist,
                    "file_is_newer": _file_is_newer,
                    # logical helpers
                    "_and_": _and_,
                    "_or_": _or_,
                }

                # Context values as local variables
                context_data = context.dict()

                try:
                    raw_result = eval(expr_safe, safe_globals, context_data)
                    result = bool(raw_result)
                except Exception as e:
                    raise RuntimeError(f"Error evaluating condition '{expr}': {e}")
        else:
            # Fallback coercion
            rendered = raw_condition
            result = bool(raw_condition)

        # Logging
        self.logger.debug(f"ConditionalStep: condition '{raw_condition}' rendered as '{rendered}' => {result}")

        # Choose branch
        branch_name = "if_true" if result else "if_false"
        branch_cfg = self.config.if_true if result else self.config.if_false
        self.logger.debug(f"ConditionalStep: executing branch '{branch_name}'")

        # Execute nested steps if any
        if branch_cfg and isinstance(branch_cfg, dict):
            steps = branch_cfg.get("steps")
            if isinstance(steps, list):
                for step_dict in steps:
                    step_type = step_dict.get("type")
                    step_conf = step_dict.get("config", {})
                    if not step_type:
                        raise RuntimeError(f"Missing 'type' in step definition in branch '{branch_name}'")
                    step_cls = STEP_REGISTRY.get(step_type)
                    if not step_cls:
                        raise RuntimeError(f"Unknown step type '{step_type}' in conditional branch '{branch_name}'")
                    step = step_cls(self.logger, step_conf)
                    await step.execute(context)
