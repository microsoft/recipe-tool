# This file was generated by Codebase-Generator, do not edit directly
import asyncio
import logging
from typing import Any, Dict, List, Optional, Set

from recipe_executor.steps.base import BaseStep, StepConfig
from recipe_executor.steps.registry import STEP_REGISTRY
from recipe_executor.protocols import ContextProtocol, StepProtocol


class ParallelConfig(StepConfig):
    """Config for ParallelStep.

    Fields:
        substeps: List of sub-step definitions, each a dict with 'type' and 'config'.
        max_concurrency: Maximum number of substeps to run concurrently. 0 means unlimited.
        delay: Optional delay (in seconds) between launching each substep.
    """

    substeps: List[Dict[str, Any]]
    max_concurrency: int = 0
    delay: float = 0.0


class ParallelStep(BaseStep[ParallelConfig]):
    """Step to execute multiple sub-steps in parallel."""

    def __init__(self, logger: logging.Logger, config: Dict[str, Any]) -> None:
        super().__init__(logger, ParallelConfig(**config))

    async def execute(self, context: ContextProtocol) -> None:
        substeps: List[Dict[str, Any]] = self.config.substeps or []
        total: int = len(substeps)
        max_conc: int = self.config.max_concurrency
        delay: float = self.config.delay

        self.logger.info(
            f"ParallelStep start: {total} substep(s), max_concurrency={max_conc or 'unlimited'}, delay={delay}"
        )

        if total == 0:
            self.logger.info("No substeps defined. Skipping ParallelStep.")
            return

        # Determine concurrency limit (0 means no limit)
        concurrency: int = total if max_conc <= 0 else min(max_conc, total)
        semaphore: asyncio.Semaphore = asyncio.Semaphore(concurrency)

        # Track first failure
        failure: Dict[str, Any] = {"exception": None, "index": None}
        tasks: List[asyncio.Task] = []

        async def run_substep(idx: int, spec: Dict[str, Any]) -> None:
            sub_logger = self.logger.getChild(f"substep_{idx}")
            try:
                sub_logger.debug(f"Cloning context for substep {idx} (type={spec.get('type')})")
                sub_context = context.clone()

                step_type = spec.get("type")
                if not step_type or step_type not in STEP_REGISTRY:
                    raise RuntimeError(f"Unknown step type '{step_type}' in substep {idx}")
                step_cfg = spec.get("config", {})

                StepCls: StepProtocol = STEP_REGISTRY[step_type]
                step_instance: StepProtocol = StepCls(sub_logger, step_cfg)

                sub_logger.info(f"Starting substep {idx}")
                await step_instance.execute(sub_context)
                sub_logger.info(f"Substep {idx} finished successfully")

            except Exception as exc:
                # Record first failure and log
                if failure["exception"] is None:
                    failure["exception"] = exc
                    failure["index"] = idx
                sub_logger.error(f"Substep {idx} failed: {exc}", exc_info=True)
                raise

            finally:
                # Release semaphore slot for next launch
                semaphore.release()

        # Launch substeps with concurrency control
        for idx, spec in enumerate(substeps):
            if failure["exception"]:
                self.logger.debug(f"Fail-fast: aborting launch at substep index {idx}")
                break

            await semaphore.acquire()
            if delay > 0:
                self.logger.debug(f"Delaying {delay}s before launching substep {idx}")
                await asyncio.sleep(delay)

            task = asyncio.create_task(run_substep(idx, spec))
            tasks.append(task)
            self.logger.debug(f"Launched substep {idx} as task {task.get_name()}")

        if not tasks:
            self.logger.info("No substeps were launched. ParallelStep complete.")
            return

        # Wait until first exception or all tasks complete
        done: Set[asyncio.Task]
        pending: Set[asyncio.Task]
        try:
            done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_EXCEPTION)
        except Exception as wait_err:
            self.logger.error("Error while waiting for substeps", exc_info=True)
            raise wait_err

        # If any substep failed, cancel pending tasks
        if failure["exception"]:
            failed_idx: Optional[int] = failure.get("index")
            self.logger.error(f"Substep {failed_idx} failed; cancelling {len(pending)} pending substep(s)")
            for task in pending:
                task.cancel()
            # Wait for cancellations to finish quietly
            await asyncio.gather(*pending, return_exceptions=True)
            raise RuntimeError(f"ParallelStep aborted due to failure in substep {failed_idx}") from failure["exception"]

        # All substeps completed successfully; ensure all are gathered
        # Some tasks may be in 'done' set
        await asyncio.gather(*pending, *done, return_exceptions=False)

        self.logger.info(f"ParallelStep completed: all {total} substep(s) succeeded")
