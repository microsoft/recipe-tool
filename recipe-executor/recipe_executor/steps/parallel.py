# This file was generated by Codebase-Generator, do not edit directly
import asyncio
import logging
from typing import Any, Dict, List, Optional

from recipe_executor.steps.base import BaseStep, StepConfig
from recipe_executor.protocols import ContextProtocol
from recipe_executor.steps.registry import STEP_REGISTRY


class ParallelConfig(StepConfig):
    """Config for ParallelStep.

    Fields:
        substeps: List of sub-step definitions to execute in parallel.
                  Each substep must be a dict with "type" and optional "config" keys.
        max_concurrency: Maximum number of substeps to run concurrently.
                         0 means no explicit limit.
        delay: Delay in seconds between launching each substep.
    """

    substeps: List[Dict[str, Any]]
    max_concurrency: int = 0
    delay: float = 0.0


class ParallelStep(BaseStep[ParallelConfig]):
    def __init__(
        self,
        logger: logging.Logger,
        config: Dict[str, Any],
    ) -> None:
        super().__init__(logger, ParallelConfig.model_validate(config))

    async def execute(self, context: ContextProtocol) -> None:
        config = self.config
        total = len(config.substeps)
        self.logger.info(
            f"Starting parallel execution of {total} sub-steps "
            f"(max_concurrency={config.max_concurrency}, delay={config.delay})"
        )
        self.logger.debug(f"ParallelConfig: {config!r}")

        # Determine concurrency limit
        if config.max_concurrency and config.max_concurrency > 0:
            semaphore = asyncio.Semaphore(config.max_concurrency)
        else:
            semaphore = asyncio.Semaphore(total if total > 0 else 1)

        # Event to signal a sub-step failure
        fail_event = asyncio.Event()
        tasks: List[asyncio.Task] = []

        async def run_substep(idx: int, substep: Dict[str, Any]) -> None:
            # Acquire a clone of the context for isolation
            subctx = context.clone()
            step_type: Optional[str] = substep.get("type")
            if not step_type:
                raise ValueError(f"Sub-step {idx} is missing 'type' key")
            self.logger.debug(f"Sub-step {idx}: preparing to run type='{step_type}'")
            try:
                # Lookup and instantiate the step

                step_cls = STEP_REGISTRY.get(step_type)
                if step_cls is None:
                    raise ValueError(f"Unknown step type '{step_type}'")
                cfg = substep.get("config", {}) or {}
                step_instance = step_cls(self.logger, cfg)
                # Execute the step (await if coroutine)
                result = step_instance.execute(subctx)
                if asyncio.iscoroutine(result):
                    await result
                self.logger.debug(f"Sub-step {idx}: completed successfully")
            except Exception as e:
                self.logger.error(f"Sub-step {idx}: failed with error: {e}", exc_info=True)
                # Signal failure to stop launching further steps
                fail_event.set()
                raise
            finally:
                # Release slot in concurrency limiter
                semaphore.release()

        # Launch sub-steps
        for idx, substep in enumerate(config.substeps, start=1):
            # Stop launching if any failure occurred
            if fail_event.is_set():
                self.logger.debug(f"Aborting launch of sub-step {idx} due to earlier failure")
                break

            # Optional staggered delay
            if config.delay and idx > 1:
                self.logger.debug(f"Delaying {config.delay}s before launching sub-step {idx}")
                await asyncio.sleep(config.delay)

            # Acquire concurrency slot
            await semaphore.acquire()
            if fail_event.is_set():
                # Release if we decided not to launch
                semaphore.release()
                break

            # Schedule execution
            task = asyncio.create_task(run_substep(idx, substep))
            tasks.append(task)

        # Wait for all started tasks to complete
        results: List[Optional[BaseException]] = []
        if tasks:
            gathered = await asyncio.gather(*tasks, return_exceptions=True)
            for result in gathered:
                if isinstance(result, BaseException):
                    results.append(result)
                else:
                    results.append(None)

        # Summarize
        failures = sum(1 for r in results if r is not None)
        successes = len(results) - failures
        self.logger.info(f"Parallel execution complete: {successes}/{total} succeeded, {failures}/{total} failed")

        if failures:
            # Raise first encountered error for fail-fast
            first_error = next(r for r in results if r is not None)
            raise RuntimeError(f"ParallelStep: {failures} of {total} sub-steps failed") from first_error
