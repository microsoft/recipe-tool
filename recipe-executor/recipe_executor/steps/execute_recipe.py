# This file was generated by Codebase-Generator, do not edit directly
import ast
from pathlib import Path
from typing import Any, Dict

from recipe_executor.steps.base import BaseStep, StepConfig
from recipe_executor.protocols import ContextProtocol
from recipe_executor.utils.templates import render_template


class ExecuteRecipeConfig(StepConfig):
    """Config for ExecuteRecipeStep.

    Fields:
        recipe_path: Path to the recipe to execute.
        context_overrides: Optional values to override in the context.
    """

    recipe_path: str
    context_overrides: Dict[str, Any] = {}


class ExecuteRecipeStep(BaseStep[ExecuteRecipeConfig]):
    """Step to execute a sub-recipe with optional context overrides."""

    def __init__(self, logger, config: Dict[str, Any]) -> None:
        # Validate config with Pydantic
        super().__init__(logger, ExecuteRecipeConfig.model_validate(config))

    async def execute(self, context: ContextProtocol) -> None:
        # Render and resolve the recipe path
        raw_path = self.config.recipe_path
        rendered_path = render_template(raw_path, context)
        recipe_file = Path(rendered_path)
        if not recipe_file.exists():
            raise FileNotFoundError(f"Sub-recipe file not found: {rendered_path}")

        # Apply context overrides
        def process_value(val: Any) -> Any:
            # Recursive processing of override values
            if isinstance(val, str):
                rendered = render_template(val, context)
                try:
                    return ast.literal_eval(rendered)
                except (ValueError, SyntaxError):
                    return rendered
            if isinstance(val, list):
                return [process_value(i) for i in val]
            if isinstance(val, dict):
                return {k: process_value(v) for k, v in val.items()}
            return val

        for key, override in self.config.context_overrides.items():
            context[key] = process_value(override)

        # Log start of sub-recipe execution
        self.logger.info(f"Executing sub-recipe: {rendered_path}")

        # Import executor here to avoid circular dependencies
        from recipe_executor.executor import Executor

        executor = Executor(self.logger)
        try:
            await executor.execute(recipe_file, context)
        except Exception as exc:
            # Propagate with recipe context
            raise RuntimeError(f"Error executing sub-recipe {rendered_path}: {exc}") from exc

        # Log completion
        self.logger.info(f"Completed sub-recipe: {rendered_path}")
