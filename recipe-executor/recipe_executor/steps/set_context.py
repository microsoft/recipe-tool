# This file was generated by Codebase-Generator, do not edit directly
from typing import Any, Dict, List, Union, Literal
import logging

from recipe_executor.steps.base import BaseStep, StepConfig
from recipe_executor.protocols import ContextProtocol
from recipe_executor.utils.templates import render_template


class SetContextConfig(StepConfig):
    """
    Config for SetContextStep.

    Fields:
        key: Name of the artifact in the Context.
        value: String, list, dict or Liquid template string rendered against
               the current context.
        nested_render: Whether to render the prompt with nested context, recursively
                       until no more templates are found.
        if_exists: Strategy when the key already exists:
                   • "overwrite" (default) – replace the existing value
                   • "merge" – combine the existing and new values
    """

    key: str
    value: Union[str, List[Any], Dict[str, Any]]
    nested_render: bool = False
    if_exists: Literal["overwrite", "merge"] = "overwrite"


class SetContextStep(BaseStep[SetContextConfig]):
    """Step to create or update an artifact in the shared execution context."""

    def __init__(self, logger: logging.Logger, config: Dict[str, Any]) -> None:
        # Validate config using Pydantic model
        validated = SetContextConfig.model_validate(config)
        super().__init__(logger, validated)

    async def execute(self, context: ContextProtocol) -> None:
        key = self.config.key
        raw_value = self.config.value
        nested = self.config.nested_render
        strategy = self.config.if_exists

        # Render templates in the raw value
        new_value = self._render_value(raw_value, context, nested)

        existed = key in context
        # Logging one-line info
        self.logger.info(f"SetContextStep: key={key}, if_exists={strategy}, existed={existed}")

        if existed and strategy == "merge":
            old_value = context[key]
            merged = self._merge_values(old_value, new_value)
            context[key] = merged
        elif not existed or strategy == "overwrite":
            if existed and strategy != "overwrite":
                # invalid strategy, will catch below
                pass
            context[key] = new_value
        else:
            raise ValueError(f"Unknown if_exists strategy: {strategy}")

    def _render_value(
        self,
        value: Any,
        context: ContextProtocol,
        nested: bool,
    ) -> Any:
        """
        Render the given value (str, list, dict) against the context.
        If nested is True, repeatedly render strings until stable or no tags.
        """
        if isinstance(value, str):
            rendered = render_template(value, context)
            if nested:
                # Repeat until no change or no template tags
                prev = None
                current = rendered
                while prev != current and ("{{" in current or "{%" in current):
                    prev = current
                    current = render_template(current, context)
                rendered = current
            return rendered
        elif isinstance(value, list):
            return [self._render_value(v, context, nested) for v in value]
        elif isinstance(value, dict):
            return {k: self._render_value(v, context, nested) for k, v in value.items()}
        else:
            # JSON-serialisable literal (int, float, bool, None)
            return value

    @staticmethod
    def _merge_values(old: Any, new: Any) -> Any:
        """
        Merge old and new values according to shallow merge semantics.
        """
        # Both strings: concatenate
        if isinstance(old, str) and isinstance(new, str):
            return old + new
        # Lists: append
        if isinstance(old, list):
            if isinstance(new, list):
                return old + new
            # new single item
            return old + [new]
        # Dicts: shallow merge
        if isinstance(old, dict) and isinstance(new, dict):
            merged = old.copy()
            merged.update(new)
            return merged
        # Mismatched or other: wrap both in a list
        return [old, new]
