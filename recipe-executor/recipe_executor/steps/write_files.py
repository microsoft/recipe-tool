# This file was generated by Codebase-Generator, do not edit directly
"""
WriteFilesStep Component

Writes files to disk based on FileSpec models or direct dict inputs.
"""

import json
import logging
import os
from pathlib import Path
from typing import Any, Dict, List, Optional

from recipe_executor.models import FileSpec
from recipe_executor.protocols import ContextProtocol
from recipe_executor.steps.base import BaseStep, StepConfig
from recipe_executor.utils.templates import render_template


class WriteFilesConfig(StepConfig):
    """
    Config for WriteFilesStep.

    Fields:
        files_key: Optional name of the context key holding a List[FileSpec] or FileSpec.
        files: Optional list of dicts with 'path', 'content' or 'path_key', 'content_key'.
        root: Optional base path to prepend to all output file paths.
    """

    files_key: Optional[str] = None
    files: Optional[List[Dict[str, Any]]] = None
    root: str = "."


class WriteFilesStep(BaseStep[WriteFilesConfig]):
    """Step that writes files to disk from context or direct input."""

    def __init__(self, logger: logging.Logger, config: Dict[str, Any]) -> None:
        super().__init__(logger, WriteFilesConfig(**config))

    async def execute(self, context: ContextProtocol) -> None:
        cfg = self.config
        logger = self.logger

        # Determine file specifications
        specs: List[FileSpec] = []

        if cfg.files is not None:
            # Use direct input
            if not isinstance(cfg.files, list):
                raise ValueError("`files` configuration must be a list of dicts")
            for idx, entry in enumerate(cfg.files):  # type: ignore
                if not isinstance(entry, dict):
                    raise ValueError(f"Entry at index {idx} in `files` is not a dict")
                # Resolve path template or key
                if "path" in entry:
                    raw_path = entry["path"]
                elif "path_key" in entry:
                    key = entry["path_key"]
                    if key not in context:
                        raise KeyError(f"Context key '{key}' not found for path_key")
                    raw_path = context[key]
                else:
                    raise ValueError(f"Entry {entry} must contain 'path' or 'path_key'")
                if not isinstance(raw_path, str):
                    raise ValueError(f"Resolved path is not a string: {raw_path!r}")
                path_rendered = render_template(raw_path, context)

                # Resolve content or content_key
                if "content" in entry:
                    content = entry["content"]
                elif "content_key" in entry:
                    ckey = entry["content_key"]
                    if ckey not in context:
                        raise KeyError(f"Context key '{ckey}' not found for content_key")
                    content = context[ckey]
                else:
                    raise ValueError(f"Entry {entry} must contain 'content' or 'content_key'")

                specs.append(FileSpec.model_validate({"path": path_rendered, "content": content}))
        elif cfg.files_key:
            # Load from context
            if cfg.files_key not in context:
                raise KeyError(f"Context does not contain key '{cfg.files_key}'")
            artifact = context[cfg.files_key]
            # Single FileSpec
            if isinstance(artifact, FileSpec):
                specs = [artifact]
            # List of FileSpec or dicts
            elif isinstance(artifact, list):  # type: ignore
                for idx, item in enumerate(artifact):
                    if isinstance(item, FileSpec):  # type: ignore
                        specs.append(item)
                    elif isinstance(item, dict):
                        specs.append(FileSpec.model_validate(item))
                    else:
                        raise ValueError(
                            f"Item at index {idx} in context['{cfg.files_key}'] is not FileSpec or dict: {type(item)}"
                        )
            # Single dict representing FileSpec
            elif isinstance(artifact, dict):
                specs = [FileSpec.model_validate(artifact)]
            else:
                raise ValueError(f"Artifact '{cfg.files_key}' must be FileSpec, dict, or list, got {type(artifact)}")
            # Render paths in specs
            rendered: List[FileSpec] = []
            for fs in specs:
                if not isinstance(fs.path, str):
                    raise ValueError(f"FileSpec.path must be str, got {type(fs.path)}")
                rendered_path = render_template(fs.path, context)
                rendered.append(FileSpec(path=rendered_path, content=fs.content))
            specs = rendered
        else:
            raise ValueError("Either 'files' or 'files_key' must be specified in WriteFilesStep config")

        # Resolve root directory
        root_rendered = render_template(cfg.root, context)
        root_path = Path(root_rendered)

        # Write each file
        for fs in specs:
            target_path = root_path / fs.path  # type: ignore
            try:
                # Prepare content string
                if isinstance(fs.content, (dict, list)):
                    try:
                        content_str = json.dumps(fs.content, ensure_ascii=False, indent=2)
                    except Exception as e:
                        logger.error(f"Failed to serialize JSON content for '{fs.path}': {e}")
                        raise
                else:
                    content_str = str(fs.content)

                # Ensure directory exists
                os.makedirs(target_path.parent, exist_ok=True)

                # Debug log before writing
                logger.debug(f"Writing file at '{target_path}' with content: {content_str!r}")

                # Write to disk
                with open(target_path, "w", encoding="utf-8") as f:
                    f.write(content_str)

                size_bytes = len(content_str.encode("utf-8"))
                logger.info(f"Wrote file '{target_path}' ({size_bytes} bytes)")
            except Exception:
                logger.exception(f"Failed to write file '{target_path}'")
                raise
