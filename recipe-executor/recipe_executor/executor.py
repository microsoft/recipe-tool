# This file was generated by Codebase-Generator, do not edit directly
import os
import json
import logging
import inspect
from pathlib import Path
from typing import Union, Dict, Any

from recipe_executor.models import Recipe
from recipe_executor.steps.registry import STEP_REGISTRY
from recipe_executor.protocols import ContextProtocol, ExecutorProtocol


class Executor(ExecutorProtocol):
    """
    Concrete implementation of ExecutorProtocol. Stateless executor that loads,
    validates, and runs a recipe's steps sequentially using a shared context.
    """

    def __init__(self, logger: logging.Logger) -> None:
        self.logger = logger

    async def execute(
        self,
        recipe: Union[str, Path, Dict[str, Any], Recipe],
        context: ContextProtocol,
    ) -> None:
        """
        Load and execute a recipe. The recipe may be a file path, JSON string,
        dict, or Recipe instance. Steps are executed in order against the context.

        Raises:
            TypeError: If recipe argument is of unsupported type.
            ValueError: If loading or validation fails, or any step fails.
        """
        # Load recipe into a dict
        recipe_dict: Dict[str, Any]
        # Determine input type
        if isinstance(recipe, Recipe):
            self.logger.debug("Loaded recipe from Recipe instance")
            recipe_obj = recipe
        else:
            if isinstance(recipe, Path):
                path_str = str(recipe)
                self.logger.debug(f"Recipe provided as Path: {path_str}")
                try:
                    with open(path_str, "r", encoding="utf-8") as f:
                        recipe_dict = json.load(f)
                except Exception as e:
                    raise ValueError(f"Failed to read recipe file '{path_str}': {e}") from e
                self.logger.debug(f"Loaded recipe from file: {path_str}")
            elif isinstance(recipe, str):
                if os.path.isfile(recipe):
                    self.logger.debug(f"Recipe string is file path: {recipe}")
                    try:
                        with open(recipe, "r", encoding="utf-8") as f:
                            recipe_dict = json.load(f)
                    except Exception as e:
                        raise ValueError(f"Failed to read recipe file '{recipe}': {e}") from e
                    self.logger.debug(f"Loaded recipe from file: {recipe}")
                else:
                    self.logger.debug("Recipe provided as raw JSON string")
                    try:
                        recipe_dict = json.loads(recipe)
                    except Exception as e:
                        raise ValueError(f"Failed to parse recipe JSON string: {e}") from e
            elif isinstance(recipe, dict):
                recipe_dict = recipe
                self.logger.debug("Loaded recipe from dict")
            else:
                raise TypeError(
                    f"Unsupported recipe type: {type(recipe).__name__}. Expected Path, str, dict, or Recipe."
                )
            # Validate and create Recipe model
            try:
                recipe_obj = Recipe.model_validate(recipe_dict)
            except Exception as e:
                raise ValueError(f"Recipe validation failed: {e}") from e

        # At this point, recipe_obj is a Recipe instance
        steps = recipe_obj.steps
        total = len(steps)
        self.logger.debug(f"Executing recipe with {total} steps")

        # Sequentially execute each step
        for index, step in enumerate(steps):  # type: ignore
            step_type = step.type
            self.logger.debug(f"About to execute step {index} of {total}: {step_type}")

            # Lookup step class
            step_class = STEP_REGISTRY.get(step_type)
            if not step_class:
                raise ValueError(f"Unknown step type '{step_type}' at index {index}")

            # Instantiate step
            try:
                step_instance = step_class(self.logger, step.config)
            except Exception as e:
                raise ValueError(f"Failed to initialize step '{step_type}' at index {index}: {e}") from e

            # Execute step
            try:
                result = step_instance.execute(context)
                if inspect.isawaitable(result):
                    await result  # type: ignore
            except Exception as e:
                msg = f"Step {index} ('{step_type}') failed: {e}"
                raise ValueError(msg) from e

            self.logger.debug(f"Step {index} ('{step_type}') completed successfully")

        self.logger.debug("All steps completed successfully")
