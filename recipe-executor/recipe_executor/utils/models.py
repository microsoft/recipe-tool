# This file was generated by Codebase-Generator, do not edit directly
"""
Provides utilities for converting JSON-Schema object definitions into Pydantic models.
"""

from typing import Any, Dict, List, Optional, Type
from pydantic import BaseModel, create_model

__all__ = ["json_object_to_pydantic_model", "json_schema_object_to_pydantic_model"]


def json_object_to_pydantic_model(object_schema: Dict[str, Any], model_name: str = "SchemaModel") -> Type[BaseModel]:
    """
    Convert a JSON object schema into a dynamic Pydantic model.

    Args:
        object_schema: A valid JSON-Schema fragment describing an object.
        model_name: Name given to the generated model class.

    Returns:
        A subclass of `pydantic.BaseModel` suitable for validation & serialization.

    Raises:
        ValueError: If the schema is invalid or unsupported.
    """
    # Validate root schema
    if not isinstance(object_schema, dict):
        raise ValueError(f"Schema must be a dict, got {type(object_schema)}")
    schema_type = object_schema.get("type")
    if schema_type != "object":
        raise ValueError(f"Root schema must be of type 'object', got '{schema_type}'")
    properties = object_schema.get("properties")
    if properties is None or not isinstance(properties, dict):
        raise ValueError("Object schema must have a 'properties' dict")
    required_fields = object_schema.get("required", [])
    if not isinstance(required_fields, list):
        raise ValueError("'required' must be a list of property names")
    for name in required_fields:
        if name not in properties:
            raise ValueError(f"Required field '{name}' not found in properties")

    # Counter for nested model names
    nested_counter = {"count": 0}

    def parse_schema(subschema: Dict[str, Any], name_hint: str) -> Any:
        """
        Parse any JSON-Schema fragment and return an appropriate Python type.
        """
        if not isinstance(subschema, dict):
            raise ValueError(f"Subschema for '{name_hint}' must be a dict, got {type(subschema)}")
        type_val = subschema.get("type")
        if not type_val or not isinstance(type_val, str):
            raise ValueError(f"Missing or invalid 'type' in subschema for '{name_hint}'")
        t = type_val.lower()
        if t == "string":
            return str
        if t == "integer":
            return int
        if t == "number":
            return float
        if t == "boolean":
            return bool
        if t in ("array", "list"):
            items = subschema.get("items")
            if items is None:
                raise ValueError(f"Array schema for '{name_hint}' must have 'items' key")
            # Determine item type
            item_type = parse_schema(items, f"{name_hint}_Item")
            return List[item_type]  # type: ignore
        if t == "object":
            # Nested object -> create a nested model
            nested_counter["count"] += 1
            nested_name = f"{name_hint}Nested{nested_counter['count']}"
            return _build_model(subschema, nested_name)
        # Fallback for unsupported types
        return Any

    def _build_model(schema: Dict[str, Any], name: str) -> Type[BaseModel]:
        """
        Build a Pydantic BaseModel subclass from an object schema.
        """
        props = schema.get("properties")
        if props is None or not isinstance(props, dict):
            raise ValueError(f"Object schema '{name}' must have a 'properties' dict")
        req = schema.get("required", [])
        if not isinstance(req, list):
            raise ValueError(f"'required' in schema '{name}' must be a list")
        fields: Dict[str, tuple] = {}
        for prop_name, prop_schema in props.items():
            # Determine field type
            field_type = parse_schema(prop_schema, f"{name}_{prop_name}")
            # Required or optional
            if prop_name in req:
                default_val = ...  # required
            else:
                # wrap optional types
                field_type = Optional[field_type]  # type: ignore
                default_val = None
            fields[prop_name] = (field_type, default_val)
        # Create model
        return create_model(name, **fields)  # type: ignore

    # Build and return the root model
    return _build_model(object_schema, model_name)


# Alias for backward compatibility or usage convenience
json_schema_object_to_pydantic_model = json_object_to_pydantic_model
