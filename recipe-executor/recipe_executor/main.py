# This file was generated by Codebase-Generator, do not edit directly
"""
Main entry point for the Recipe Executor system.
Parses command-line arguments, initializes logging, context, and executor,
and orchestrates recipe execution with proper error handling.
"""

import sys
import argparse
import asyncio
import time
import traceback
from typing import Dict, List

from dotenv import load_dotenv

from recipe_executor.logger import init_logger
from recipe_executor.context import Context
from recipe_executor.executor import Executor
import logging


def parse_key_value_list(kv_list: List[str], arg_name: str) -> Dict[str, str]:
    """
    Parse a list of strings in key=value format into a dictionary.

    Raises:
        ValueError: If any entry does not contain '=' or has empty key.
    """
    result: Dict[str, str] = {}
    for item in kv_list:
        if "=" not in item:
            raise ValueError(f"Invalid {arg_name} format '{item}', expected key=value")
        key, value = item.split("=", 1)
        if not key:
            raise ValueError(f"Invalid {arg_name} format '{item}', key cannot be empty")
        result[key] = value
    return result


async def main_async(
    recipe_path: str,
    context: Context,
    executor: Executor,
    logger: logging.Logger,
) -> None:
    """
    Asynchronous core logic: execute the recipe and report timing.
    """
    start_time = time.monotonic()
    await executor.execute(recipe_path, context)
    elapsed = time.monotonic() - start_time
    logger.info(f"Recipe executed successfully in {elapsed:.2f} seconds")


def main() -> None:
    # Load environment variables from .env if present
    load_dotenv()

    parser = argparse.ArgumentParser(description="Recipe Executor Tool")
    parser.add_argument("recipe_path", help="Path to the recipe file to execute.")
    parser.add_argument("--log-dir", default="logs", help="Directory for log files (default: logs)")
    parser.add_argument("--context", action="append", default=[], help="Context artifact as key=value (repeatable)")
    parser.add_argument("--config", action="append", default=[], help="Configuration value as key=value (repeatable)")
    args = parser.parse_args()

    # Parse context artifacts
    try:
        artifacts = parse_key_value_list(args.context, "context")
    except ValueError as e:
        sys.stderr.write(f"Context Error: {e}\n")
        sys.exit(1)

    # Parse configuration values
    try:
        config = parse_key_value_list(args.config, "config")
    except ValueError as e:
        sys.stderr.write(f"Config Error: {e}\n")
        sys.exit(1)

    # Initialize logger
    try:
        logger = init_logger(log_dir=args.log_dir)
    except Exception as e:
        sys.stderr.write(f"Logger Error: {e}\n")
        sys.exit(1)

    # Log startup and parsed arguments for traceability
    logger.debug(
        f"Parsed arguments: recipe_path={args.recipe_path}, "
        f"log_dir={args.log_dir}, context={artifacts}, config={config}"
    )
    logger.info("Starting Recipe Executor Tool")

    # Create context and executor
    context = Context(artifacts=artifacts, config=config)
    executor = Executor(logger)

    # Run the asynchronous execution
    try:
        asyncio.run(main_async(args.recipe_path, context, executor, logger))
    except Exception as e:
        logger.error(f"An error occurred during recipe execution: {e}")
        # Print stack trace to stderr for debugging
        sys.stderr.write(traceback.format_exc())
        sys.exit(1)

    sys.exit(0)


if __name__ == "__main__":  # pragma: no cover
    main()
